/** LANL:license
 * -------------------------------------------------------------------------
 * This SOFTWARE has been authored by an employee or employees of the
 * University of California, operator of the Los Alamos National Laboratory
 * under Contract No. W-7405-ENG-36 with the U.S. Department of Energy.
 * The U.S. Government has rights to use, reproduce, and distribute this
 * SOFTWARE.  The public may copy, distribute, prepare derivative works and
 * publicly display this SOFTWARE without charge, provided that this Notice
 * and any statement of authorship are reproduced on all copies.  Neither
 * the Government nor the University makes any warranty, express or implied,
 * or assumes any liability or responsibility for the use of this SOFTWARE.
 * If SOFTWARE is modified to produce derivative works, such modified
 * SOFTWARE should be clearly marked, so as not to confuse it with the
 * version available from LANL.
 * -------------------------------------------------------------------------
 * LANL:license
 * -------------------------------------------------------------------------
 */
package jGEP;

import java.util.Vector;

/**
 * This class is a basic individual that can evolve expressions
 * representing arithmetic operations over multiple variables
 * and involving the +,*,-,/ operators.
 *
 * @author    Matthew Sottile
 * @version   1.0
 */
public class ArithmeticIndividual extends Individual {
    /**
     * Constructor.
     *
     * @param  s  Chromosome containing symbols and functions in the given
     *            genome.
     * @param  g  The genome from which the chromosome for this individual
     *            derives.
     * @param  gc Gene count.
     */
    public ArithmeticIndividual(String s, Genome g, int gc) throws Exception {
        super(s,g,gc);
    }

    public ArithmeticIndividual(Genome g, int gc) throws Exception {
        super(g,gc);
    }

    /**
     * Clone this individual.
     *
     * @return    A new object instance identical to this one.
     */
    public Individual replicate() {
        try {
            return new ArithmeticIndividual(chromosome,genome,genes);
        } catch (Exception e) {
            System.err.println("EXCEPTION (replicate) :: "+e.toString());
        }
        return null;
    }

    /**
     * Express this individual as an expression tree for basic
     * arithmetic expressions (+,-,/,*,^,sqrt).
     *
     * @return    A forest of trees representing the expression
     *            trees generated by each gene for this individual.
     */
    public ExpressionNode[] express() {
        int numGenes = chromosome.length() / genome.getGeneLength();
        Vector stack;
        ExpressionNode roots[] = new ExpressionNode[numGenes];
        int pos;

        for (int curGene = 0; curGene < numGenes; curGene++) {
            pos = curGene*genome.getGeneLength();
            stack = new Vector();
            int geneEnd = pos+genome.getGeneLength();

            boolean done = false;
            int need = 1;

            while (pos < geneEnd && done == false) {
                char c = chromosome.charAt(pos);
                need--;

                if (genome.isFunction(c)) {
                    stack.addElement(new Character(c));
                    need += 2;
                } else {
                    stack.addElement(new Character(c));
                } 
                pos++;
                if (need == 0) done = true;
            }
            
            for (int i = stack.size() - 1; i >= 0; i--) {
                Character c = (Character)stack.elementAt(i);
                char ch = c.charValue();
                ArithmeticExpressionNode n = new ArithmeticExpressionNode(ch);
                stack.setElementAt(n,i);
                if (genome.isFunction(ch)) {
                    n.setRight((ArithmeticExpressionNode)stack.elementAt(stack.size()-1));
                    n.setLeft((ArithmeticExpressionNode)stack.elementAt(stack.size()-2));
                    stack.removeElementAt(stack.size()-1);
                    stack.removeElementAt(stack.size()-1);
                }
            }

            roots[curGene] = (ArithmeticExpressionNode)stack.elementAt(0);
        }

        return roots;
    }

    /**
     * Inner class implementing the specific expression node this
     * individual will use.
     *
     * Inner classes are good for this since the node type is intimately
     * bound to the individual, and we don't want it available outside.
     * When we pass it out (if ever), others can use it if they
     * expect a generic ExpressionNode object.
     *
     * @author   Matthew Sottile
     * @version  1.0
     */
    class ArithmeticExpressionNode implements ExpressionNode {
        private ArithmeticExpressionNode left, right;
        private char c;

        public ArithmeticExpressionNode(char c) {
            this.c = c;
        }

        public String stringRepresentation() {
            String s = "";
            if (genome.isFunction(c)) {
                s = "("+left.stringRepresentation() + " " + c + " " 
                    + right.stringRepresentation() + ")";
            } else {
                s = ""+c;
            }

            return s;
        }
        
        public Object evaluate(java.util.Hashtable values) throws Exception {
            Double lval = null;
            Double rval = null;

            if (genome.isFunction(c)) {
                switch(c) {
                case '+':
                    lval = (Double)left.evaluate(values);
                    rval = (Double)right.evaluate(values);

                    return new Double(lval.doubleValue() + 
                                      rval.doubleValue());

                case '-':
                    lval = (Double)left.evaluate(values);
                    rval = (Double)right.evaluate(values);

                    return new Double(lval.doubleValue() - 
                                      rval.doubleValue());
                case '/':
                    rval = (Double)right.evaluate(values);
                    if (rval.doubleValue() == 0.0) {
                        throw new Exception("Division by zero in evaluate.");
                    }
                    lval = (Double)left.evaluate(values);

                    return new Double(lval.doubleValue() / 
                                      rval.doubleValue());
                case '*':
                    lval = (Double)left.evaluate(values);
                    rval = (Double)right.evaluate(values);

                    return new Double(lval.doubleValue() * 
                                      rval.doubleValue());
                default:
                    throw new Exception("Unimplemented function : "+c);
                }
            } else {
                Double value = (Double)values.get(""+c);
                if (value == null) {
                    throw new Exception("No value named "+c);
                } 
                return value;
            }
        }

        protected void setLeft(ArithmeticExpressionNode l) {
            left = l;
        }

        protected void setRight(ArithmeticExpressionNode r) {
            right = r;
        }
    }
}
